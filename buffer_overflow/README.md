# Buffer Overflow Example
This example demonstrates a basic buffer overflow vulnerability in C programming language. The program accepts an
input string from the user, copies it into a fixed-size buffer without checking if it fits, and then prints the
buffer content. This may lead to unexpected behavior when the input is longer than expected.

**Usage:**
Compile the program using `gcc -o overflow_example overflow_example.c` and run with `./overflow_example <input>`.

**Code:**
```c
// Include necessary libraries:
#include <stdio.h>
#include <string.h>

int main(int argc, char *argv[]) {
    // Declare a small buffer of size 5
    char buffer[5];

    if (argc < 2) {
        // Check if input is provided
        printf("Usage: %s <input>\n", argv[0]);
        return 1;
    }

    // Copy the input string into the small buffer without checking its size
    strcpy(buffer, argv[1]);

    // Print the content of the buffer
    printf("Buffer content: %s\n", buffer);

    return 0;
}
```
**Explanation:**
This code is vulnerable to a buffer overflow attack because it doesn't check if the input string provided by the
user fits into the `buffer` array. If the input string is longer than the buffer size (5 bytes), it will overwrite
memory beyond the allocated buffer, potentially leading to unpredictable program behavior or security
vulnerabilities.

>>> Overwriting Return Address: If the overflow overwrites the return address, the program might jump to an arbitrary lo
... cation in memory when the function returns, potentially executing malicious code.
... Corrupting Variables: Other local variables or control data can be corrupted, leading to unpredictable behavior or crashes.
 You are correct! Let's elaborate on how overwriting the return address and corrupting variables can lead to
buffer overflow vulnerabilities.

**Overwriting Return Address:**
When a function is called in C, the program pushes its return address onto the stack. This address points to the
next instruction to be executed after the current function finishes. If an attacker can overwrite this return
address with another memory address (e.g., the start of their malicious code), the program will jump to that
location and execute the attacker's code when the function returns. This is known as "Return-Oriented Programming"
or ROP, which is a common technique used in buffer overflow attacks.

**Corrupting Variables:**
In addition to the return address, local variables, pointers, and control data (e.g., function arguments) are also
stored on the stack in memory adjacent to the buffer. If an attacker can overwrite these values with their own,
they can manipulate the program's control flow, potentially causing crashes or unintended behavior. This is known
as a "Stack Smashing" attack.

In both cases, the attacker relies on the fact that C does not perform bounds checking when copying strings into
buffers. By providing an input string that is longer than expected, they can overwrite adjacent memory locations
with their own data and potentially gain control of the program or execute arbitrary code.